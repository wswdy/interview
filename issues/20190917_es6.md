ES6+ 数组相关方法分查看20190902_Array

###### 变量提升、块级作用域、暂时性死区


*************
###### 模版字符串的应用


*************
###### 箭头函数


*************
###### 解构赋值


*************
###### import  exports（模块化语法）


*************
###### Promise


*************
###### Proxy(代理器)
Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对象对该对象的访问，都必须先通过这层拦截。因此提供了一种机制，可以对外界的访问进行过滤和改写。
1. 可以使用get方法实现继承

```
const person = {
    name: 'kid',
    age: 27,
    say: function() {
        console.log('hello');
    }
};

// target参数表示要拦截的对象，这里指的就是person
const child = new Proxy(person, {
    get: function(target, propKey) {
       if (propKey in target) {
			return target[propKey];
		} else {
			throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
		}
    }
});

child.name; // kid
child.age;  // 27
child.say();    //hello    
```
ps：当访问目标对象不存在的属性，会抛出一个错误。如果平常我去访问一个对象不存在的属性，只会返回undefined。

2. set方法拦截某个属性的赋值操作
方法一共接受4个参数，依次为目标对象、属性名、属性值和Proxy实例本身，最后一个参数可选。

```
// 在拦截上面定义的person对象的age属性，该属性应该是一个不大于35的整数
let validatorAge = new Proxy(person, {
   set: function(target, propKey, value) {
       if (propKey === 'age') {
          if (!Number.isInteger(value)) {
               throw new TypeError('The age is not an integer');
          }
          if (value > 35) {
               throw new RangeError('The age seems invalid');
           }
       }
       
       // 对于满足条件的 age 属性以及其他属性，直接保存
       target[propKey] = value;
   }
});

// 换种方式写
let validator = {
    set: function(target, propKey, value) {
       if (propKey === 'age') {
          if (!Number.isInteger(value)) {
               throw new TypeError('The age is not an integer');
          }
          if (value > 35) {
               throw new RangeError('The age seems invalid');
           }
       }
       
       // 对于满足条件的 age 属性以及其他属性，直接保存
       target[propKey] = value;
   }
};
// let validatorAge  = new Proxy(person, validator);

validatorAge.age = 28;

validatorAge.age;   // 28
validatorAge.age = 'young'; // 报错
validatorAge.age = 38;  // 报错
```
