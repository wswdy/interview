js  执行上下文

###### 什么是执行上下文？
当函数执行时，会创建一个称为执行上下文的内部对象（可理解为作用域）。一个执行上下文（Execution Context）定义了一个函数执行时的环境。  
执行上下文分为创建阶段和执行阶段：
- 创建阶段（Variable Object）  
（1）创建作用域链  
（2）创建变量对象（变量对象用于存储上下文中变量和函数声明，是执行上下文相关的数据作用域）  
（3）确定this的指向  
- 执行阶段（Active Object）  
（1）各项属性赋值，执行上下文对象更新

- 变量对象的创建过程：  
（1）建立arguments对象。检查上下文中的参数，建立该对象下的属性与属性值（key-value）  
（2）检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数
     所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。
（3）检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名
     的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。
     
********************
###### js执行栈？
代码执行遇到js代码，就会创建一个全局执行栈，遇到函数就会给每个函数创建自有的执行栈，js执行栈遵循先入后出的原则
```
// 搞清以下两个的区别
var count = 0;
function foo1() {
    count += 1;
    console.log(count);
}
foo1(count);
foo1(count);

function foo2(count) {
    count += 1;
    console.log(count);
}
foo2(count);
foo2(count);
```
********************
###### 函数中this的理解？
非严格模式下，全局环境中的this是window对象；严格模式时为undefined。  
一般情况，this是函数执行时获得的属性，this最终指向的是那个调用它的对象。  
箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。

********************
###### 作用域和作用域链？
额，这题怎么解释呢。就是函数内引用了一个变量，执行时会首先在函数体内查找这个变量，如果没有就会随着作用域链向上查找这个变量，直到全局环境，
如果全局环境中也不存在，则报错。

********************
###### 闭包？优缺点？
闭包是通过函数嵌套函数的形式，使得内部函数可以引用外部函数的参数和变量  
- 优点  
全局变量可能会造成命名冲突，使用闭包将变量私有化，加强了封装性，使得变量不被污染
- 缺点  
由于闭包可以使得外部函数的变量不被销毁而一直存在内存中，如果对闭包处理不当，就可能会出现内存溢出的问题  
内存溢出的处理方式可以是在函数执行结束后，通过标记fun=null，使垃圾回收机制将它回收释放内存。  
- 引申： 垃圾回收机制  
（1）标记清除  
在函数中声明一个变量时，标记它为“进入环境”，函数执行结束，标记为“离开环境”，垃圾回收机制会给环境中所有的变量都添加一个标记，
然后去掉环境中的变量和被环境中变量引用的变量的标记，剩下的就是没被引用的，就是即将被垃圾回收机制清除并回收内存的变量。
（2）引用计数  
当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。
当该值引用次数为0时就会被回收。

********************
###### call和apply？（还有个bind）
call(), apply(), bind() 都可以用于改变this的指向  
- call  
Function.prototype.call(thisArg [, arg1 [, arg2, ...]])，对于 call() 而言，它的第一个参数为需要绑定的对象，也就是 this 指向的对象  
- apply  
apply() 的用法和 call() 类似，唯一的区别是它们接收参数的形式不同。除了第一个参数外，call() 是以枚举的形式传入一个个的参数，而 apply() 是传入一个数组。
- bind  
与 call() 和 apply() 直接执行原函数不同的是，bind() 返回的是一个新函数。简单说，bind() 的作用就是将原函数的 this 绑定到指定对象，
并返回一个新的函数，以延迟原函数的执行，这在异步流程中（比如回调函数，事件处理程序）具有很强大的作用。

